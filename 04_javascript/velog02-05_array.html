<!DOCTYPE html>
<html lang="ko">
  <head>
    <title>Array</title>
    <script>
      let arr1 = [1, 2, 3]; // [1, 2, 3] 배열 생성
      let arr2 = Array(1, 2, 3); // 상동
      let arr3 = Array(3); // 길이가 3인 빈 배열 생성
      let arr4 = Array.of(3); // [3] 배열 생성
      console.log(arr1);
      console.log(arr2);
      console.log(arr3);
      console.log(arr4);
      let arr5 = Array.of("12345"); //길이가 1
      console.log(arr5);
      let arr6 = Array.from("12345"); //길이가 5
      console.log(arr6);

      let arr = [10, 20, 30];
      console.log(arr[0], arr.at(0), arr[4], arr.at(4)); // 인덱싱: 10, 10, undefined, undefined 반환
      console.log(arr[-1], arr.at(-1), arr.at(-9)); // undefined, 30, undefined 반환
      console.log(arr.slice(9, 99), arr.slice(-999, -9)); // Array.slice(s, e): 슬라이싱. s부터(이상) e까지(미만) 반환
      let [a, b, c] = arr6; // 다중 할당: 배열 값을 변수로 할당()
      console.log(a, b, c);
      // `...`(나머지 연산자): 여러 인자를 배열로 받음
      let [a2, b2, ...c2] = arr6;
      console.log(a2, b2, c2);

      arr.push(40);
      console.log(arr.length, arr); // 끝에 40 추가
      arr[4] = 50; // 인덱스 4에 50 추가
      console.log(arr);
      arr[9] = 60; // 인덱스 9에 60 추가, 빈 자리는 empty
      console.log(arr);
      arr.push(70, 80, 90); // 계속해서 끝에 추가. 한 번에 여러 원소 추가
      console.log(arr);
      arr.unshift(0); // 맨 앞에 값 추가
      console.log(arr);
      arr.unshift(100, 110); // 여러 원소 맨 앞에 추가
      console.log(arr);
      arr[0] = 0; // 값 변환
      console.log(arr);

      // 값 탐색
      console.log(arr.includes(0), arr.includes(400));
      // Array.indexof(value, startIndex): startIndex부터 해서 value가 있는 index 반환. 부재시 -1
      console.log(arr.indexOf(0), arr.indexOf(0, 1), arr.indexOf(0, 3));
      // Array.splice(start_index, delete_count, insert_nums): start_index에서부터 delete_count만큼 값 제거 후 insuert_nums를 삽입.
      arr.splice(-199, 5, 1, 1);
      // start_index가 index 범위를 초과하는 경우  마지막 값으로 인식
      // delete_count가 0이하인 경우 제거 없이 삽입
      // insert nums 부재 시 delete_count까지만 작동.
      // insert nums눈 delete_count와 별개로 순차적으로 값 삽입
      console.log(arr);
      // 마지막 값 반환 및 제거
      arr.pop();
      console.log(arr);
      console.log(arr.pop());
      // 처음 값 반환 및 제거
      console.log(arr);
      arr.shift();
      console.log(arr);
      console.log(arr.shift());
      // 지우고 empty로 남김
      delete arr[1];
      console.log(arr);

      // 배열 합치기
      let arrA = [10, 20, 30];
      let arrB = [30, 40, 50];
      let arrC = arrA.concat(arrB);
      console.log(arrC);
      let arrC2 = arrA + arrB; // 문자열 연산이 되어 버림
      console.log(typeof arrC2, arrC2);

      // 정렬
      // 값 타입 변수 vs 참조 타입 변수
      // 값 타입은 메모리 공간에 실제 값 가짐
      // 기본데이터타입 : number,string,boolean,undefined,null,symbol
      // 참조 타입은 메모리 공간에 실제값의 주소값을 가짐
      // 객체타입: object,Array,Function,Map,Set
      let arrD = [20, 10, 30, 40, 50];
      let sortedArray = arrD;
      // 주소값을 복사하여 하나가 바뀌면 둘 다 바뀜
      let orgArray = [...arrD]; // `...`(배열 전개 연산자): 배열의 값을 나열함
      // 새로운 주소에 값을 복사하여 별도 작동
      console.log(arrD);
      // Array.sort(); // 원본을 변경
      sortedArray.sort();
      console.log(arrD);
      console.log(sortedArray);
      console.log(orgArray);
      // Array.reverse(): 내림차순 정렬
      sortedArray.reverse();
      console.log(arrD);

      // 다중 할당
      let [e1, e2, e3, e4, e5] = arrD;
      console.log(e1, e2, e3, e4, e5);
      let [e6, e7] = arrD;
      console.log(e6, e7);
      let [e8, ...e9] = arrD;
      console.log(e8, e9);
    </script>
  </head>
  <body></body>
</html>
